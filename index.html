<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Learner V2.6 (Mobile Pronounce Fix)</title> <!-- Version Bump -->
    <style>
        /* --- General Layout & Body --- */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.5;
        }

        #app-container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }

        h1 {
            margin-top: 0;
            color: #333;
        }

        /* --- Error & Status Messages --- */
        #loading-error {
             color: red;
             font-weight: bold;
             margin-bottom: 15px;
        }

        #status-message {
            margin-top: 20px;
            font-style: italic;
            color: #666;
            min-height: 1.2em; /* Ensure space for messages */
        }

        #session-complete {
            font-size: 1.2em;
            color: #28a745;
            margin-top: 20px;
            font-weight: bold;
        }

        /* --- Controls --- */
        #controls {
            margin-bottom: 20px;
            display: flex; /* Use flexbox for alignment */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center items */
            align-items: center; /* Vertically align items */
            gap: 15px; /* Space between controls */
        }

        /* Style for the new pronunciation controls container */
        .pronunciation-controls {
            display: flex;
            flex-direction: row; /* Ensure horizontal layout */
            align-items: center;
            gap: 8px; /* Space between elements */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center the controls */
            /* Removed margin-top to rely on parent gap */
        }

        /* Style the dropdown */
        #language-select {
            padding: 5px 8px;
            font-size: 0.9em;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
        }
        #language-select:disabled {
             background-color: #e9ecef;
             cursor: not-allowed;
        }


        /* Style the pronounce button */
        #pronounce-btn {
            padding: 5px 10px;
            font-size: 1.2em;
            line-height: 1;
            background-color: #17a2b8;
            min-width: 40px;
            color: white;
            border: none;
            border-radius: 4px;
        }
        #pronounce-btn:hover:not(:disabled) {
             background-color: #138496;
             opacity: 1;
        }
        #pronounce-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Style for the error indicator */
        #pronounce-error {
            font-size: 1.2em;
            color: #dc3545; /* Red color for error */
            font-weight: bold;
            cursor: help; /* Indicate it's informative */
            margin-left: 2px; /* Tiny space from button */
        }


        /* --- Card Area --- */
        #card-area {
            margin-top: 15px;
        }

        #card-display {
            min-height: 150px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #foreign-word {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #0056b3;
            word-break: break-word;
        }

        /* --- Answer Input & Feedback --- */
        #answer-input-area {
            margin-top: 10px;
            margin-bottom: 15px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

         #answer-input {
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
            box-sizing: border-box;
         }
         #answer-input:disabled {
            background-color: #e9ecef;
            opacity: 0.8;
            cursor: not-allowed;
         }


        #feedback {
            min-height: 1.2em;
            font-weight: bold;
            margin-top: 5px;
        }
        .correct { color: #28a745; }
        .incorrect { color: #dc3545; }

        #translation {
            font-size: 1.5em;
            color: #28a745;
            margin-top: 10px;
            display: none; /* Hidden initially */
            word-break: break-word;
        }

        /* --- Button Styles --- */
        .button-container {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: white;
            background-color: #007bff;
        }
        button:hover:not(:disabled) {
            opacity: 0.9;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Specific Button Styles */
        #assessment-buttons button {
             border-radius: 20px;
             color: white;
        }
        #again-btn { background-color: #dc3545; }
        #again-btn:hover:not(:disabled) { background-color: #c82333; opacity: 1; }
        #hard-btn { background-color: #ffc107; color: #333; }
        #hard-btn:hover:not(:disabled) { background-color: #e0a800; opacity: 1; }
        #good-btn { background-color: #28a745; }
        #good-btn:hover:not(:disabled) { background-color: #218838; opacity: 1; }
        #easy-btn { background-color: #17a2b8; }
        #easy-btn:hover:not(:disabled) { background-color: #138496; opacity: 1; }


        #check-answer-btn {
            background-color: #007bff;
            color: white;
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 5px;
            margin-top: 5px;
        }
        #check-answer-btn:hover:not(:disabled) {
            background-color: #0056b3;
            opacity: 1;
        }

        #new-session-btn {
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 5px;
        }
         #new-session-btn:hover:not(:disabled) {
             background-color: #5a6268;
             opacity: 1;
         }

        #show-answer-btn {
            background-color: #6c757d;
            color: white;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
        }
        #show-answer-btn:hover:not(:disabled) {
            background-color: #5a6268;
            opacity: 1;
        }

        /* --- Utility Classes --- */
        .hidden {
            display: none !important;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .button-with-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .time-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 0;
            line-height: 1;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1>Flashcard Learner</h1>
        <div id="loading-error" class="hidden"></div>

        <div id="controls" class="hidden">
             <button id="new-session-btn">Start New Session</button>
             <!-- Pronunciation Controls: Visible by default via CSS -->
             <div class="pronunciation-controls">
                 <label for="language-select" class="visually-hidden">Pronunciation Language:</label>
                 <select id="language-select">
                     <option value="fr">French</option>
                     <option value="en">English</option>
                 </select>
                 <button id="pronounce-btn" title="Pronounce Translated Word" disabled>üîä</button> <!-- Disabled until voice ready -->
                 <span id="pronounce-error" class="hidden" title="Speech synthesis unavailable or voice not found">‚ùì</span> <!-- Hidden until error -->
             </div>
        </div>

        <div id="card-area" class="hidden">
            <div id="card-display">
                <div id="foreign-word"></div>
                <div id="translation"></div>
                <div id="answer-input-area">
                     <input type="text" id="answer-input" placeholder="Type the translation...">
                     <div class="button-container" style="margin-top: 0;"> <!-- Container for check/show -->
                        <button id="check-answer-btn">Check Typing</button>
                     </div>
                     <button id="show-answer-btn">Show Answer</button>
                     <div id="feedback"></div>
                </div>
            </div>

            <div id="assessment-buttons" class="button-container hidden">
                <div class="button-with-label">
                    <span class="time-label"><1m</span>
                    <button id="again-btn">Again</button>
                </div>
                <div class="button-with-label">
                    <span class="time-label"><6m</span>
                    <button id="hard-btn">Hard</button>
                </div>
                 <div class="button-with-label">
                    <span class="time-label"><10m</span>
                    <button id="good-btn">Good</button>
                </div>
                <div class="button-with-label">
                    <span class="time-label">4d</span>
                    <button id="easy-btn">Easy</button>
                </div>
            </div>
        </div>

        <div id="status-message">Loading words...</div>

        <div id="session-complete" class="hidden">
            üéâ Session Complete! Use "Start New Session" to go again. üéâ
        </div>
    </div>

    <script>
        (function() { // IIFE
            "use strict";

            // --- Constants ---
            const WORDS_FILE_PATH = 'words.json';
            const LOCAL_STORAGE_KEYS = {
                SHUFFLED_INDICES: 'flashcard_shuffledIndices',
                CURRENT_INDEX: 'flashcard_currentIndex',
                CARDS_LENGTH: 'flashcard_cardsLength'
            };
            const PRONUNCIATION_LANG_KEY = 'flashcard_pronunciationLang';
            const AGAIN_OFFSET = 1;
            const HARD_OFFSET = 5;
            const GOOD_OFFSET = 10;

            // --- DOM Elements ---
            const loadingErrorEl = document.getElementById('loading-error');
            const controlsEl = document.getElementById('controls');
            const newSessionBtn = document.getElementById('new-session-btn');
            const cardArea = document.getElementById('card-area');
            const foreignWordEl = document.getElementById('foreign-word');
            const answerInputArea = document.getElementById('answer-input-area');
            const answerInput = document.getElementById('answer-input');
            const feedbackEl = document.getElementById('feedback');
            const translationEl = document.getElementById('translation');
            const checkAnswerBtn = document.getElementById('check-answer-btn');
            const showAnswerBtn = document.getElementById('show-answer-btn');
            const assessmentButtons = document.getElementById('assessment-buttons');
            const againBtn = document.getElementById('again-btn');
            const hardBtn = document.getElementById('hard-btn');
            const goodBtn = document.getElementById('good-btn');
            const easyBtn = document.getElementById('easy-btn');
            const statusMessage = document.getElementById('status-message');
            const sessionCompleteMessage = document.getElementById('session-complete');
            const languageSelect = document.getElementById('language-select');
            const pronounceBtn = document.getElementById('pronounce-btn');
            const pronounceError = document.getElementById('pronounce-error');
            // No need for pronunciationControls variable directly now

            // --- State Variables ---
            let cards = [];
            let shuffledIndices = [];
            let currentCardIndex = 0;
            let currentCardData = null;
            let selectedLang = 'fr';
            let synth = window.speechSynthesis;
            let voices = [];
            let voiceLoadTimeout = null; // To manage the fallback timeout

            // --- Speech Synthesis Functions ---

            /** Populates the `voices` array and updates UI based on availability. */
            function populateVoiceList() {
                if (!synth) return;
                try {
                    voices = synth.getVoices();
                    if (voices.length > 0) {
                        console.log(`Voices loaded (${voices.length}). First voice: ${voices[0].name} (${voices[0].lang})`);
                        // Clear any pending timeout fallback if voices load via event
                        if (voiceLoadTimeout) clearTimeout(voiceLoadTimeout);
                        checkVoiceAvailability(selectedLang); // Update UI now that voices are known
                    } else {
                        console.log("populateVoiceList called, but getVoices() returned empty list.");
                    }
                } catch (error) {
                    console.error("Error calling synth.getVoices():", error);
                    showPronunciationError("Error getting synthesis voices.");
                }
            }

            /** Finds a suitable voice for the given language code. */
            function findVoice(langCode) {
                if (!voices || voices.length === 0) return null;

                const langLower = langCode.toLowerCase();
                const langPrefix = langLower + '-';

                // 1. Exact match (e.g., 'fr-FR' for 'fr-FR') - case-insensitive
                let voice = voices.find(v => v.lang.toLowerCase() === langLower);
                if (voice) return voice;

                // 2. Prefix match (e.g., 'fr-CA' for 'fr') - case-insensitive
                voice = voices.find(v => v.lang.toLowerCase().startsWith(langPrefix));
                if (voice) return voice;

                // 3. Base language match if code includes region (e.g., 'en' for 'en-US')
                if (langLower.includes('-')) {
                    const baseLang = langLower.split('-')[0];
                    voice = voices.find(v => v.lang.toLowerCase() === baseLang);
                    if (voice) return voice;
                    // Try prefix match for base language too (e.g. find 'en-GB' if base was 'en')
                     voice = voices.find(v => v.lang.toLowerCase().startsWith(baseLang + '-'));
                     if (voice) return voice;
                }

                console.log(`findVoice: No specific voice found for ${langCode}.`);
                return null;
            }

            /** Checks if a voice is available and updates the pronounce button/error state. */
            function checkVoiceAvailability(langCode) {
                 if (!synth) {
                     showPronunciationError("Speech synthesis not supported.");
                     languageSelect.disabled = true; // Also disable select if no synth
                     return false;
                 }

                 const hasAnyVoices = voices && voices.length > 0;
                 const voice = findVoice(langCode);
                 // Button should only be enabled if there's a card loaded AND its translation exists
                 const canEnablePronounceButton = currentCardData !== null && currentCardData.translated;

                 if (voice) {
                     // console.log(`Voice found for ${langCode}.`);
                     pronounceError.classList.add('hidden'); // Hide error indicator
                     pronounceBtn.disabled = !canEnablePronounceButton; // Enable/disable based on card state
                     return true;
                 } else if (hasAnyVoices) {
                     // Other voices exist, maybe a browser default/fallback will work
                     console.warn(`No specific voice found for ${langCode}, but other voices exist. Attempting fallback.`);
                     pronounceError.classList.add('hidden'); // Hide error, let user try
                     pronounceBtn.disabled = !canEnablePronounceButton; // Enable/disable based on card state
                     return true; // Allow attempt
                 } else {
                     // No voices loaded at all (yet?). Keep button disabled.
                     // Don't show the error indicator immediately, wait for the timeout in initializeSpeechSynthesis.
                     console.log("checkVoiceAvailability: No voices loaded yet.");
                     pronounceBtn.disabled = true; // Keep disabled
                     return false;
                 }
             }

            /** Speaks the given text using the selected voice/language. */
            function pronounceWord(text) {
                if (!synth || !text || pronounceBtn.disabled) {
                    console.warn("Pronounce called but synth not ready, no text, or button disabled.");
                    return;
                }
                // Cancel any ongoing speech first
                if (synth.speaking) {
                    console.log("Cancelling previous speech.");
                    synth.cancel();
                 }

                const utterance = new SpeechSynthesisUtterance(text);
                const voice = findVoice(selectedLang);

                if (voice) {
                    utterance.voice = voice;
                    utterance.lang = voice.lang; // Important: Use the specific voice lang
                    console.log(`Speaking "${text}" using voice: ${voice.name} (${voice.lang})`);
                } else {
                    utterance.lang = selectedLang; // Fallback to language code
                    console.warn(`No specific voice found for ${selectedLang}. Attempting default fallback with lang="${selectedLang}".`);
                }

                // --- Utterance Event Handlers ---
                utterance.onstart = () => {
                    // console.log("Speech started.");
                    pronounceBtn.disabled = true; // Disable button WHILE speaking
                };

                utterance.onend = () => {
                    // console.log("Speech finished.");
                    // Re-enable button *if* appropriate (checks voice and card state)
                    checkVoiceAvailability(selectedLang);
                };

                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror:', event);
                    showPronunciationError(`Speech error: ${event.error}`);
                    // Re-enable button *if* appropriate, even after error
                    checkVoiceAvailability(selectedLang);
                };

                // Clear previous visual errors and attempt to speak
                pronounceError.classList.add('hidden');
                try {
                    synth.speak(utterance);
                } catch (error) {
                    console.error("Error calling synth.speak:", error);
                    showPronunciationError(`Error starting speech: ${error.message}`);
                    checkVoiceAvailability(selectedLang); // Ensure button state is correct after error
                }
            }

            /** Shows the pronunciation error indicator (‚ùì) and disables the button. */
            function showPronunciationError(message = "Speech synthesis unavailable or voice not found") {
                 console.warn("Pronunciation Error:", message);
                 if (pronounceError) {
                     pronounceError.classList.remove('hidden');
                     pronounceError.title = message; // Set hover/tooltip text
                 }
                 if (pronounceBtn) pronounceBtn.disabled = true; // Ensure button is disabled
            }

            /** Initializes speech synthesis, tries to load voices, sets up fallback. */
            function initializeSpeechSynthesis() {
                 // Check for browser support
                 if ('speechSynthesis' in window && window.speechSynthesis) {
                    synth = window.speechSynthesis;
                    languageSelect.disabled = false; // Enable dropdown

                    // Load saved language preference
                    const savedLang = localStorage.getItem(PRONUNCIATION_LANG_KEY);
                    selectedLang = (savedLang && (savedLang === 'en' || savedLang === 'fr')) ? savedLang : 'fr';
                    languageSelect.value = selectedLang;

                    // --- Event Listeners for Pronunciation Controls ---
                    languageSelect.addEventListener('change', (event) => {
                        selectedLang = event.target.value;
                        localStorage.setItem(PRONUNCIATION_LANG_KEY, selectedLang);
                        if (synth.speaking) synth.cancel(); // Stop speech on lang change
                        checkVoiceAvailability(selectedLang); // Update button for new lang
                        console.log("Pronunciation language changed to:", selectedLang);
                    });

                    pronounceBtn.addEventListener('click', () => {
                         if (currentCardData && currentCardData.translated) {
                             pronounceWord(currentCardData.translated);
                         }
                    });

                    // --- Voice Loading Logic ---
                    // 1. Set up the event listener (primary method)
                    if (synth.onvoiceschanged !== undefined) {
                         synth.onvoiceschanged = populateVoiceList;
                     }

                    // 2. Attempt immediate population (might be empty on some browsers)
                    populateVoiceList();

                    // 3. Set a timeout fallback (for browsers where onvoiceschanged is unreliable or slow)
                    // Clear any previous timeout just in case this function is called again
                    if (voiceLoadTimeout) clearTimeout(voiceLoadTimeout);

                    voiceLoadTimeout = setTimeout(() => {
                        console.log("Voice loading timeout reached.");
                        if (voices.length === 0) {
                            console.log("Still no voices after timeout, attempting populateVoiceList again.");
                            populateVoiceList(); // Try one last time
                        }
                        // *After* the final attempt, check if voices loaded.
                        if (voices.length === 0) {
                             console.warn("No speech synthesis voices found after delay/event.");
                             showPronunciationError("No speech synthesis voices found in this browser.");
                        } else {
                            // Voices might have loaded via the event or this timeout's call.
                            // Ensure the UI is up-to-date.
                            checkVoiceAvailability(selectedLang);
                        }
                    }, 1500); // Increased timeout to 1.5 seconds for mobile

                } else {
                    // Speech synthesis not supported at all
                    console.warn("Speech Synthesis API not supported by this browser.");
                    showPronunciationError("Speech synthesis not supported by this browser.");
                    languageSelect.disabled = true; // Disable controls permanently
                    pronounceBtn.disabled = true;
                }
            }


            // --- Core Flashcard Functions (Mostly Unchanged) ---

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function saveProgress() {
                try {
                    const indexToSave = Math.min(currentCardIndex, shuffledIndices.length);
                    localStorage.setItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES, JSON.stringify(shuffledIndices));
                    localStorage.setItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX, indexToSave.toString());
                    localStorage.setItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH, cards.length.toString());
                } catch (error) {
                    console.error("Error saving progress:", error);
                    statusMessage.textContent = "Warning: Could not save progress.";
                }
            }

            function loadProgress() {
                try {
                    const savedIndices = localStorage.getItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES);
                    const savedIndex = localStorage.getItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX);
                    const savedLength = localStorage.getItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH);

                    if (savedIndices && savedIndex && savedLength) {
                        const parsedIndices = JSON.parse(savedIndices);
                        const parsedIndex = parseInt(savedIndex, 10);
                        const parsedLength = parseInt(savedLength, 10);

                        if (Array.isArray(parsedIndices) &&
                            !isNaN(parsedIndex) && !isNaN(parsedLength) &&
                            parsedLength === cards.length && // Must match current deck size
                            parsedIndex >= 0 && parsedIndex <= parsedIndices.length &&
                            parsedIndices.every(idx => typeof idx === 'number' && idx >= 0 && idx < cards.length))
                           {
                            shuffledIndices = parsedIndices;
                            currentCardIndex = parsedIndex;
                            console.log(`Progress loaded. Resuming at index ${currentCardIndex}/${shuffledIndices.length}.`);
                            return true;
                        } else {
                            console.warn("Saved progress invalid/mismatched. Clearing.");
                            clearSavedProgress();
                        }
                    }
                } catch (error) {
                    console.error("Error loading/parsing progress:", error);
                    clearSavedProgress();
                }
                return false;
            }


            function clearSavedProgress() {
                try {
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES);
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX);
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH);
                    // Don't clear language preference: localStorage.removeItem(PRONUNCIATION_LANG_KEY);
                    console.log("Saved session progress cleared.");
                } catch (error) {
                    console.error("Error clearing progress:", error);
                }
            }

            function displayCard() {
                // Reset UI
                translationEl.style.display = 'none';
                assessmentButtons.classList.add('hidden');
                checkAnswerBtn.style.display = 'inline-block';
                checkAnswerBtn.disabled = false;
                showAnswerBtn.style.display = 'inline-block';
                answerInputArea.style.display = 'flex';
                answerInput.value = '';
                answerInput.disabled = false;
                feedbackEl.textContent = '';
                feedbackEl.className = 'feedback';
                sessionCompleteMessage.classList.add('hidden');
                checkAnswerBtn.parentElement.style.display = 'flex'; // Show check/show container

                // --- Session Completion Check ---
                if (currentCardIndex >= shuffledIndices.length) {
                    cardArea.classList.add('hidden');
                    controlsEl.classList.remove('hidden');
                    statusMessage.textContent = `Finished reviewing all scheduled cards.`;
                    sessionCompleteMessage.classList.remove('hidden');
                    currentCardData = null; // Clear card data
                    pronounceBtn.disabled = true; // Disable pronounce button when done
                    saveProgress();
                    console.log("Session complete.");
                    return;
                }

                // --- Load Card Data ---
                const actualIndex = shuffledIndices[currentCardIndex];
                 if (typeof actualIndex !== 'number' || actualIndex < 0 || actualIndex >= cards.length) {
                     console.error('Invalid index in shuffledIndices:', actualIndex, 'at pos', currentCardIndex);
                     statusMessage.textContent = `Error: Invalid card sequence. Recovering...`;
                     shuffledIndices.splice(currentCardIndex, 1); // Remove bad index
                     saveProgress();
                     displayCard(); // Retry display
                     return;
                 }
                currentCardData = cards[actualIndex];

                if (!currentCardData || typeof currentCardData.original !== 'string' || typeof currentCardData.translated !== 'string') {
                    console.error('Invalid card data:', currentCardData, 'at original index', actualIndex);
                    statusMessage.textContent = `Error: Invalid card content. Skipping.`;
                    currentCardIndex++; // Skip potential bad card
                    saveProgress();
                    displayCard();
                    return;
                }

                // --- Update UI ---
                foreignWordEl.textContent = currentCardData.original;
                translationEl.textContent = currentCardData.translated; // Pre-set for later display

                cardArea.classList.remove('hidden');
                controlsEl.classList.remove('hidden');
                statusMessage.textContent = `Card ${currentCardIndex + 1} of ${shuffledIndices.length} in queue.`;
                answerInput.focus();

                // Update pronunciation state for the new card (button will be enabled only if answer shown later)
                // Initially, button should be disabled as translation is hidden.
                pronounceBtn.disabled = true;
                // But we still check availability to ensure error state is correct if voices never loaded
                checkVoiceAvailability(selectedLang);
                // Re-enable based on checkVoiceAvailability *after* answer is shown/checked
            }

            function checkAnswer() {
                if (!currentCardData) return;

                const userAnswer = answerInput.value.trim().toLowerCase();
                const correctAnswer = currentCardData.translated.trim().toLowerCase();

                answerInput.disabled = true;
                checkAnswerBtn.style.display = 'none';
                showAnswerBtn.style.display = 'none';
                checkAnswerBtn.parentElement.style.display = 'none'; // Hide container

                feedbackEl.textContent = userAnswer === correctAnswer ? "Correct!" : `Incorrect. Correct: ${currentCardData.translated}`;
                feedbackEl.className = userAnswer === correctAnswer ? 'feedback correct' : 'feedback incorrect';

                translationEl.style.display = 'block';
                assessmentButtons.classList.remove('hidden');
                assessmentButtons.style.display = 'flex';
                 // Now that translation is visible, check if pronunciation can be enabled
                 checkVoiceAvailability(selectedLang);
            }

            function showAnswer() {
                if (!currentCardData) return;
                answerInput.disabled = true;
                checkAnswerBtn.style.display = 'none';
                showAnswerBtn.style.display = 'none';
                checkAnswerBtn.parentElement.style.display = 'none';

                feedbackEl.textContent = `Correct: ${currentCardData.translated}`;
                feedbackEl.className = 'feedback';
                translationEl.style.display = 'block';
                assessmentButtons.classList.remove('hidden');
                assessmentButtons.style.display = 'flex';
                // Now that translation is visible, check if pronunciation can be enabled
                checkVoiceAvailability(selectedLang);
            }

            function repeatCardLater(offset) {
                if (currentCardIndex >= shuffledIndices.length || currentCardData === null) {
                    moveToNextCard(); // Go to end state or next valid card
                    return;
                }
                const cardToRepeatOriginalIndex = shuffledIndices[currentCardIndex];
                let insertionIndex = currentCardIndex + offset + 1;
                insertionIndex = Math.min(insertionIndex, shuffledIndices.length);

                shuffledIndices.splice(insertionIndex, 0, cardToRepeatOriginalIndex);
                console.log(`Repeating card (orig idx ${cardToRepeatOriginalIndex}) at queue pos ${insertionIndex}. New len: ${shuffledIndices.length}`);

                currentCardIndex++;
                saveProgress();
                displayCard();
            }

            function moveToNextCard() {
                if (currentCardIndex < shuffledIndices.length) {
                     currentCardIndex++;
                }
                saveProgress(); // Save progress regardless
                displayCard(); // Handles showing next card or completion
            }

            function startReviewSession(forceNew = false) {
                if (cards.length === 0) {
                    statusMessage.textContent = "No cards loaded.";
                    cardArea.classList.add('hidden');
                    controlsEl.classList.add('hidden');
                    return;
                }

                controlsEl.classList.remove('hidden'); // Show controls area

                if (forceNew) {
                    clearSavedProgress();
                }

                const resumed = !forceNew && loadProgress();

                if (!resumed) {
                    currentCardIndex = 0;
                    shuffledIndices = Array.from(cards.keys());
                    shuffleArray(shuffledIndices);
                    console.log("Starting new session.");
                    saveProgress(); // Save initial state
                }

                sessionCompleteMessage.classList.add('hidden');
                statusMessage.textContent = `Loaded ${cards.length} cards. ${resumed ? 'Resuming session.' : 'Starting new session.'}`;

                // Initialize speech synthesis *after* knowing session state but *before* first displayCard
                initializeSpeechSynthesis();

                displayCard(); // Display first card
            }

            async function loadWords() {
                statusMessage.textContent = `Loading words from ${WORDS_FILE_PATH}...`;
                loadingErrorEl.classList.add('hidden');
                cardArea.classList.add('hidden');
                controlsEl.classList.add('hidden'); // Hide controls during load

                try {
                    const response = await fetch(WORDS_FILE_PATH, { cache: "no-store" });
                    if (!response.ok) throw new Error(`HTTP ${response.status}. Could not fetch '${WORDS_FILE_PATH}'.`);

                    const jsonData = await response.json();
                    if (!Array.isArray(jsonData)) throw new Error("JSON data is not an array.");

                    const isValid = jsonData.every(item =>
                         typeof item === 'object' && item !== null &&
                         typeof item.original === 'string' && item.original.trim() &&
                         typeof item.translated === 'string' && item.translated.trim()
                     );
                     if (!isValid && jsonData.length > 0) throw new Error("JSON objects invalid (missing/empty keys).");

                    cards = jsonData;
                    console.log(`Loaded ${cards.length} cards.`);
                    startReviewSession(); // Start session (will show controls)

                } catch (error) {
                    console.error("Error loading words:", error);
                    loadingErrorEl.textContent = `Error: ${error.message}`;
                    loadingErrorEl.classList.remove('hidden');
                    statusMessage.textContent = "Failed to load cards.";
                    cards = [];
                    cardArea.classList.add('hidden');
                    controlsEl.classList.add('hidden'); // Keep controls hidden on error
                    // Ensure pronunciation controls reflect error state
                    languageSelect.disabled = true;
                    pronounceBtn.disabled = true;
                    showPronunciationError(error.message); // Show error indicator
                }
            }

            // --- Global Event Listeners ---
            document.addEventListener('DOMContentLoaded', () => {
                 // Don't initialize speech synth here, let loadWords->startReviewSession handle it
                 // after cards are loaded (or fail to load).
                 loadWords();
            });

            // Card Interaction
            checkAnswerBtn.addEventListener('click', checkAnswer);
            showAnswerBtn.addEventListener('click', showAnswer);
            answerInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !answerInput.disabled && checkAnswerBtn.style.display !== 'none') {
                     event.preventDefault();
                    checkAnswer();
                }
            });

            // Assessment Buttons
            againBtn.addEventListener('click', () => repeatCardLater(AGAIN_OFFSET));
            hardBtn.addEventListener('click', () => repeatCardLater(HARD_OFFSET));
            goodBtn.addEventListener('click', () => repeatCardLater(GOOD_OFFSET));
            easyBtn.addEventListener('click', moveToNextCard);

            // New Session Button
            newSessionBtn.addEventListener('click', () => {
                console.log("Starting new session manually...");
                if (synth && synth.speaking) synth.cancel();
                startReviewSession(true); // Force new
            });

        })(); // End IIFE
    </script>

</body>
</html>
