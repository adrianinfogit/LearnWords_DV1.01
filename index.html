<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Learner V2.5 (Pronounce Translated)</title>
    <style>
        /* --- General Layout & Body --- */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.5;
        }

        #app-container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 500px; /* Adjusted max-width slightly */
            text-align: center;
        }

        h1 {
            margin-top: 0;
            color: #333;
        }

        /* --- Error & Status Messages --- */
        #loading-error {
             color: red;
             font-weight: bold;
             margin-bottom: 15px;
        }

        #status-message {
            margin-top: 20px;
            font-style: italic;
            color: #666;
            min-height: 1.2em; /* Ensure space for messages */
        }

        #session-complete {
            font-size: 1.2em;
            color: #28a745;
            margin-top: 20px;
            font-weight: bold;
        }

        /* --- Controls --- */
        #controls {
            margin-bottom: 20px;
            display: flex; /* Use flexbox for alignment */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center items */
            align-items: center; /* Vertically align items */
            gap: 15px; /* Space between controls */
        }

        /* Style for the new pronunciation controls container */
        .pronunciation-controls {
            display: flex;
            flex-direction: row; /* Ensure horizontal layout */
            align-items: center;
            gap: 8px; /* Space between elements */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center the controls */
            margin-top: 10px; /* Add spacing for better visibility */
        }

        /* Style the dropdown */
        #language-select {
            padding: 5px 8px;
            font-size: 0.9em;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white; /* Ensure background color */
            cursor: pointer;
        }

        /* Style the pronounce button */
        #pronounce-btn {
            padding: 5px 10px;
            font-size: 1.2em; /* Adjust size for emoji if needed */
            line-height: 1; /* Ensure button height fits content */
            background-color: #17a2b8; /* Example color */
            min-width: 40px; /* Ensure minimum width */
            color: white; /* Ensure text/emoji is visible */
            border: none; /* Added */
            border-radius: 4px; /* Added */
        }
        #pronounce-btn:hover:not(:disabled) {
             background-color: #138496;
             opacity: 1;
        }
        #pronounce-btn:disabled {
            background-color: #ccc; /* Consistent disabled style */
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Style for the error indicator */
        #pronounce-error {
            font-size: 1.2em;
            color: #dc3545; /* Red color for error */
            font-weight: bold;
            cursor: help; /* Indicate it's informative */
        }


        /* --- Card Area --- */
        #card-area {
            margin-top: 15px;
        }

        #card-display {
            min-height: 150px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #foreign-word {
            font-size: 1.5em; /* Match the size of #translation */
            margin-bottom: 15px;
            color: #0056b3;
            word-break: break-word;
        }

        /* --- Answer Input & Feedback --- */
        #answer-input-area {
            margin-top: 10px;
            margin-bottom: 15px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

         #answer-input {
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
            box-sizing: border-box;
         }
         #answer-input:disabled {
            background-color: #e9ecef;
            opacity: 0.8;
            cursor: not-allowed;
         }


        #feedback {
            min-height: 1.2em;
            font-weight: bold;
            margin-top: 5px;
        }
        .correct { color: #28a745; }
        .incorrect { color: #dc3545; }

        #translation {
            font-size: 1.5em;
            color: #28a745;
            margin-top: 10px;
            display: none; /* Hidden initially */
            word-break: break-word;
        }

        /* --- Button Styles --- */
        .button-container {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px; /* Default slightly rounded */
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: white;
            background-color: #007bff; /* Default blue */
        }
        button:hover:not(:disabled) {
            opacity: 0.9;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Specific Button Styles */
        #assessment-buttons button {
             border-radius: 20px; /* Squircle shape for assessment */
             color: white;
        }
        #again-btn { background-color: #dc3545; }
        #again-btn:hover:not(:disabled) { background-color: #c82333; opacity: 1; }
        #hard-btn { background-color: #ffc107; color: #333; }
        #hard-btn:hover:not(:disabled) { background-color: #e0a800; opacity: 1; }
        #easy-btn { background-color: #17a2b8; }
        #easy-btn:hover:not(:disabled) { background-color: #138496; opacity: 1; }

        /* Removed the Good button styles */
        #good-btn {
            background-color: #28a745;
        }
        #good-btn:hover:not(:disabled) {
            background-color: #218838;
            opacity: 1;
        }

        #check-answer-btn { /* Small utility button */
            background-color: #007bff;
            color: white;
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 5px;
            margin-top: 5px; /* Spacing */
        }
        #check-answer-btn:hover:not(:disabled) {
            background-color: #0056b3;
            opacity: 1;
        }

        #new-session-btn { /* Small utility button */
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 5px;
        }
         #new-session-btn:hover:not(:disabled) {
             background-color: #5a6268;
             opacity: 1;
         }

        #show-answer-btn { /* Normal button style */
            background-color: #6c757d;
            color: white;
            /* Removed margin-top to rely on flex gap */
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
        }
        #show-answer-btn:hover:not(:disabled) {
            background-color: #5a6268;
            opacity: 1;
        }

        /* --- Utility Classes --- */
        .hidden {
            display: none !important;
        }

        /* Class to visually hide labels but keep them for screen readers */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .button-with-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .time-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 0; /* Removed bottom margin, rely on gap */
            line-height: 1; /* Ensure compact */
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1>Flashcard Learner</h1>
        <div id="loading-error" class="hidden"></div>

        <div id="controls" class="hidden">
             <button id="new-session-btn">Start New Session</button>
             <!-- === Pronunciation Controls START === -->
             <!-- These are now visible by default, JS handles button state -->
             <div class="pronunciation-controls">
                 <label for="language-select" class="visually-hidden">Pronunciation Language:</label>
                 <select id="language-select">
                     <option value="fr">French</option>
                     <option value="en">English</option>
                 </select>
                 <button id="pronounce-btn" title="Pronounce Translated Word" disabled>üîä</button> <!-- Still disabled initially -->
                 <span id="pronounce-error" class="hidden" title="Speech synthesis unavailable or voice not found">‚ùì</span> <!-- Still hidden initially -->
             </div>
             <!-- === Pronunciation Controls END === -->
        </div>

        <div id="card-area" class="hidden">
            <div id="card-display">
                <div id="foreign-word"></div>
                <div id="translation"></div>
                <div id="answer-input-area">
                     <input type="text" id="answer-input" placeholder="Type the translation...">
                     <!-- Added a container for the check/show buttons -->
                     <div class="button-container" style="margin-top: 0;">
                        <button id="check-answer-btn">Check Typing</button>
                     </div>
                     <button id="show-answer-btn">Show Answer</button>
                     <div id="feedback"></div>
                </div>
            </div>

            <div id="assessment-buttons" class="button-container hidden">
                <div class="button-with-label">
                    <span class="time-label"><1m</span>
                    <button id="again-btn">Again</button>
                </div>
                <div class="button-with-label">
                    <span class="time-label"><6m</span>
                    <button id="hard-btn">Hard</button>
                </div>
                 <div class="button-with-label">
                    <span class="time-label"><10m</span>
                    <button id="good-btn">Good</button> <!-- Re-added Good button definition -->
                </div>
                <div class="button-with-label">
                    <span class="time-label">4d</span>
                    <button id="easy-btn">Easy</button>
                </div>
            </div>
        </div>

        <div id="status-message">Loading words...</div>

        <div id="session-complete" class="hidden">
            üéâ Session Complete! Use "Start New Session" to go again. üéâ
        </div>
    </div>

    <script>
        (function() { // IIFE to encapsulate scope
            "use strict";

            // --- Constants ---
            const WORDS_FILE_PATH = 'words.json';
            const LOCAL_STORAGE_KEYS = {
                SHUFFLED_INDICES: 'flashcard_shuffledIndices',
                CURRENT_INDEX: 'flashcard_currentIndex',
                CARDS_LENGTH: 'flashcard_cardsLength'
            };
            const PRONUNCIATION_LANG_KEY = 'flashcard_pronunciationLang'; // For saving language preference
            // --- Updated constants for repetition offsets ---
            const AGAIN_OFFSET = 1; // Repeat immediately after next card
            const HARD_OFFSET = 5;  // Repeat after approx 5 cards
            const GOOD_OFFSET = 10; // Repeat after approx 10 cards

            // --- DOM Elements ---
            const loadingErrorEl = document.getElementById('loading-error');
            const controlsEl = document.getElementById('controls');
            const newSessionBtn = document.getElementById('new-session-btn');
            const cardArea = document.getElementById('card-area');
            const foreignWordEl = document.getElementById('foreign-word');
            const answerInputArea = document.getElementById('answer-input-area');
            const answerInput = document.getElementById('answer-input');
            const feedbackEl = document.getElementById('feedback');
            const translationEl = document.getElementById('translation');
            const checkAnswerBtn = document.getElementById('check-answer-btn');
            const showAnswerBtn = document.getElementById('show-answer-btn');
            const assessmentButtons = document.getElementById('assessment-buttons');
            const againBtn = document.getElementById('again-btn');
            const hardBtn = document.getElementById('hard-btn');
            const goodBtn = document.getElementById('good-btn'); // Get the Good button
            const easyBtn = document.getElementById('easy-btn');
            const statusMessage = document.getElementById('status-message');
            const sessionCompleteMessage = document.getElementById('session-complete');

            // --- Pronunciation Elements ---
            const languageSelect = document.getElementById('language-select');
            const pronounceBtn = document.getElementById('pronounce-btn');
            const pronounceError = document.getElementById('pronounce-error');
            const pronunciationControls = document.querySelector('.pronunciation-controls'); // Get the container

            // --- State Variables ---
            let cards = [];
            let shuffledIndices = [];
            let currentCardIndex = 0;
            let currentCardData = null;
            let selectedLang = 'fr'; // Default language
            let synth = window.speechSynthesis; // Speech Synthesis API
            let voices = []; // To store available voices

            // --- Speech Synthesis Functions ---

            function populateVoiceList() {
                if (!synth) return;
                voices = synth.getVoices();
                 // Update UI based on newly populated voices immediately
                 checkVoiceAvailability(selectedLang);
            }

            function findVoice(langCode) {
                if (!voices || voices.length === 0) {
                    console.log("findVoice: No voices available yet.");
                    return null;
                }
                const langPrefix = langCode + '-';
                // Prioritize voices matching the exact code or prefix
                let voice = voices.find(v => v.lang.toLowerCase() === langCode.toLowerCase() || v.lang.toLowerCase().startsWith(langPrefix.toLowerCase()));
                if (voice) {
                    // console.log(`findVoice: Found specific voice for ${langCode}: ${voice.name} (${voice.lang})`);
                    return voice;
                }
                // Less ideal: Find any voice for the base language (e.g., 'en' if 'en-US' wasn't found)
                const baseLang = langCode.split('-')[0];
                voice = voices.find(v => v.lang.toLowerCase().startsWith(baseLang.toLowerCase()));
                if(voice) {
                    console.log(`findVoice: Found fallback voice for base language ${baseLang}: ${voice.name} (${voice.lang})`);
                    return voice;
                }

                console.log(`findVoice: No suitable voice found for ${langCode}.`);
                return null; // Explicitly return null if no voice found
            }

             function checkVoiceAvailability(langCode) {
                 if (!synth) {
                     showPronunciationError("Speech synthesis not supported by browser.");
                     return false;
                 }

                 const hasAnyVoices = voices && voices.length > 0;
                 const voice = findVoice(langCode);
                 const canEnablePronounceButton = currentCardData !== null && currentCardData.translated;

                 if (voice) {
                     // console.log(`Voice found for ${langCode}. Enabling button if card data present.`);
                     pronounceError.classList.add('hidden');
                     pronounceBtn.disabled = !canEnablePronounceButton;
                     return true;
                 } else if (hasAnyVoices) {
                     // We have voices, just not the specific one. Maybe a fallback will work.
                     console.warn(`No specific voice found for ${langCode}, but other voices exist. Fallback might work. Button enabled.`);
                     pronounceError.classList.add('hidden'); // Hide specific error, but log warning
                     pronounceBtn.disabled = !canEnablePronounceButton;
                     return true; // Allow attempting pronunciation
                 } else {
                     // No voices loaded at all yet OR browser truly has none.
                     console.error(`No voice found for language code '${langCode}' and no voices seem available yet.`);
                     // Only show the error indicator if we're reasonably sure no voices exist after a delay (handled in initialization)
                     // pronounceBtn.disabled = true; // Keep it disabled
                     // Don't necessarily show the error yet, wait for timeout in init.
                     // If called later (e.g., on language change) and still no voices, the init logic should have already shown the error.
                      pronounceBtn.disabled = true; // Ensure it's disabled if no voice found
                     return false;
                 }
             }

            function pronounceWord(text) {
                if (!synth || !text || pronounceBtn.disabled) {
                    console.warn("Pronounce called but synth not ready, no text, or button disabled.");
                    return;
                }
                // Cancel any ongoing speech
                if (synth.speaking) {
                    console.log("Cancelling previous speech.");
                    synth.cancel();
                 }

                const utterance = new SpeechSynthesisUtterance(text);
                const voice = findVoice(selectedLang);

                if (voice) {
                    utterance.voice = voice;
                    utterance.lang = voice.lang; // Use the voice's specific lang tag
                    console.log(`Speaking "${text}" using voice: ${voice.name} (${voice.lang})`);
                } else {
                    // Attempt to speak using the selected language code directly as a fallback
                    utterance.lang = selectedLang;
                    console.warn(`No specific voice found for ${selectedLang}. Attempting default fallback with lang="${selectedLang}".`);
                }

                 // Set volume and rate if desired
                 // utterance.volume = 1; // 0 to 1
                 // utterance.rate = 1; // 0.1 to 10
                 // utterance.pitch = 1; // 0 to 2

                utterance.onstart = () => {
                    // console.log("Speech started.");
                    pronounceBtn.disabled = true; // Disable button while speaking
                };

                utterance.onend = () => {
                    // console.log("Speech finished.");
                     // Re-enable button only if a card is loaded (checkVoiceAvailability does this)
                     checkVoiceAvailability(selectedLang);
                };

                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event);
                    showPronunciationError(`Speech error: ${event.error}`);
                    // Re-enable button even on error if appropriate
                    checkVoiceAvailability(selectedLang);
                };

                // Clear previous errors and try speaking
                pronounceError.classList.add('hidden');
                try {
                    synth.speak(utterance);
                } catch (error) {
                    console.error("Error calling synth.speak:", error);
                    showPronunciationError(`Error starting speech: ${error.message}`);
                     checkVoiceAvailability(selectedLang); // Ensure button state is correct after error
                }
            }

            function showPronunciationError(message = "Speech synthesis unavailable or voice not found") {
                 console.warn("Pronunciation Error:", message);
                 if (pronounceError) {
                     pronounceError.classList.remove('hidden');
                     pronounceError.title = message; // Set hover text
                 }
                 if (pronounceBtn) pronounceBtn.disabled = true; // Ensure button is disabled on error
            }

            function initializeSpeechSynthesis() {
                 // *** CHANGE: Removed the line that hides pronunciationControls ***
                 // if (pronunciationControls) pronunciationControls.style.display = 'none';

                 if ('speechSynthesis' in window && window.speechSynthesis) {
                    synth = window.speechSynthesis;

                    // Load saved language preference
                    const savedLang = localStorage.getItem(PRONUNCIATION_LANG_KEY);
                    if (savedLang && (savedLang === 'en' || savedLang === 'fr')) {
                        selectedLang = savedLang;
                    }
                    languageSelect.value = selectedLang; // Update dropdown to match

                    // --- Event Listeners for Pronunciation ---
                    languageSelect.addEventListener('change', (event) => {
                        selectedLang = event.target.value;
                        localStorage.setItem(PRONUNCIATION_LANG_KEY, selectedLang);
                        // Re-check voice availability for the new language and update button state
                        checkVoiceAvailability(selectedLang);
                        console.log("Pronunciation language changed to:", selectedLang);
                        // If synth was speaking, changing language should stop it
                        if (synth.speaking) {
                            synth.cancel();
                        }
                    });

                    pronounceBtn.addEventListener('click', () => {
                         if (currentCardData && currentCardData.translated) {
                             pronounceWord(currentCardData.translated);
                         } else {
                             console.warn("Pronounce button clicked, but no current card data or translation available.");
                         }
                    });

                    // --- Voice Loading Logic ---
                    // The 'voiceschanged' event is crucial but can be unreliable or delayed.
                    if (synth.onvoiceschanged !== undefined) {
                         synth.onvoiceschanged = () => {
                             console.log("onvoiceschanged event fired.");
                             populateVoiceList();
                         };
                     }

                    // Attempt immediate population (might be empty)
                    populateVoiceList();

                    // If voices loaded immediately, check availability
                    if (voices.length > 0) {
                         console.log("Voices available immediately.");
                         checkVoiceAvailability(selectedLang);
                    } else {
                         // If no voices yet, set a timeout as a fallback mechanism,
                         // as 'onvoiceschanged' might not fire reliably on all browsers/platforms.
                         console.log("Voices not immediately available, setting timeout fallback.");
                         setTimeout(() => {
                             console.log("Timeout check for voices executing...");
                             // If voices haven't loaded by now via the event, try populating again.
                             if (voices.length === 0) {
                                 console.log("Still no voices after timeout, attempting populateVoiceList again.");
                                 populateVoiceList();
                             }
                             // After the timeout, whether voices came from the event or the timeout call,
                             // perform the check and potentially show the error if still no voices.
                             if (voices.length > 0) {
                                 console.log("Voices loaded after timeout.");
                                 checkVoiceAvailability(selectedLang);
                             } else {
                                 console.warn("No speech synthesis voices found after delay.");
                                 showPronunciationError("No speech synthesis voices found in this browser.");
                             }
                         }, 1000); // Increased timeout slightly
                     }
                } else {
                    console.warn("Speech Synthesis API not supported by this browser.");
                    showPronunciationError("Speech synthesis not supported by this browser.");
                    // Disable related controls permanently if API is missing
                    languageSelect.disabled = true;
                    pronounceBtn.disabled = true;
                }
            }


            // --- Core Functions ---

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function saveProgress() {
                try {
                    // Ensure index doesn't exceed length if session just completed
                    const indexToSave = Math.min(currentCardIndex, shuffledIndices.length);
                    localStorage.setItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES, JSON.stringify(shuffledIndices));
                    localStorage.setItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX, indexToSave.toString());
                    localStorage.setItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH, cards.length.toString());
                    // console.log('Progress saved. Index:', indexToSave, 'Shuffled length:', shuffledIndices.length);
                } catch (error) {
                    console.error("Error saving progress to localStorage:", error);
                    statusMessage.textContent = "Warning: Could not save progress.";
                }
            }

            function loadProgress() {
                try {
                    const savedIndices = localStorage.getItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES);
                    const savedIndex = localStorage.getItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX);
                    const savedLength = localStorage.getItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH);

                    if (savedIndices && savedIndex && savedLength) {
                        const parsedIndices = JSON.parse(savedIndices);
                        const parsedIndex = parseInt(savedIndex, 10);
                        const parsedLength = parseInt(savedLength, 10);

                        // Stricter Validation:
                        if (Array.isArray(parsedIndices) &&
                            !isNaN(parsedIndex) &&
                            !isNaN(parsedLength) &&
                            parsedLength === cards.length && // Deck size *must* match exactly
                            parsedIndex >= 0 &&
                            parsedIndex <= parsedIndices.length && // Index can be equal to length (session finished)
                            // Ensure all saved indices are valid *numbers* within the bounds of the *current* cards array
                            parsedIndices.every(idx => typeof idx === 'number' && idx >= 0 && idx < cards.length))
                           {
                            shuffledIndices = parsedIndices;
                            currentCardIndex = parsedIndex;
                            console.log(`Progress loaded. Resuming at index ${currentCardIndex} of ${shuffledIndices.length} cards in queue.`);
                            return true; // Successfully loaded and validated
                        } else {
                            console.warn("Saved progress is invalid or doesn't match the current card deck. Clearing old progress.");
                            clearSavedProgress(); // Clear invalid data
                        }
                    }
                } catch (error) {
                    // Catch JSON parsing errors or other issues
                    console.error("Error loading or parsing progress from localStorage:", error);
                    clearSavedProgress(); // Clear potentially corrupt data
                }
                return false; // Loading failed or data was invalid
            }


            function clearSavedProgress() {
                try {
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.SHUFFLED_INDICES);
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.CURRENT_INDEX);
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.CARDS_LENGTH);
                    // Don't clear language preference: localStorage.removeItem(PRONUNCIATION_LANG_KEY);
                    console.log("Saved session progress cleared.");
                } catch (error) {
                    console.error("Error clearing progress from localStorage:", error);
                }
            }

            function displayCard() {
                // Reset UI state for a new card
                translationEl.style.display = 'none';
                assessmentButtons.classList.add('hidden');
                assessmentButtons.style.display = ''; // Reset direct style if set previously
                checkAnswerBtn.style.display = 'inline-block';
                checkAnswerBtn.disabled = false;
                showAnswerBtn.style.display = 'inline-block';
                answerInputArea.style.display = 'flex';
                answerInput.value = '';
                answerInput.disabled = false;
                feedbackEl.textContent = '';
                feedbackEl.className = 'feedback';
                sessionCompleteMessage.classList.add('hidden');
                // Ensure check/show buttons parent container is visible
                checkAnswerBtn.parentElement.style.display = 'flex';


                // --- Session Completion Check ---
                if (currentCardIndex >= shuffledIndices.length) {
                    cardArea.classList.add('hidden');
                    controlsEl.classList.remove('hidden'); // Ensure controls are visible
                    statusMessage.textContent = `Finished reviewing all scheduled cards.`;
                    sessionCompleteMessage.classList.remove('hidden');
                    if (pronounceBtn) pronounceBtn.disabled = true; // Disable pronunciation when no card is shown
                    currentCardData = null; // Clear current card data
                    saveProgress(); // Save the final completed state (index = length)
                    console.log("Session complete.");
                    return; // Stop further execution for this function call
                }

                // --- Load Card Data ---
                const actualIndex = shuffledIndices[currentCardIndex];
                 if (typeof actualIndex === 'undefined' || actualIndex < 0 || actualIndex >= cards.length) {
                     console.error('Invalid index found in shuffledIndices:', actualIndex, 'at queue position', currentCardIndex, 'Queue:', shuffledIndices);
                     statusMessage.textContent = `Error: Invalid card sequence. Attempting to recover...`;
                     // Recovery attempt: Remove the invalid index and try again
                     shuffledIndices.splice(currentCardIndex, 1);
                     saveProgress(); // Save the modified queue
                     displayCard(); // Recursive call to try the (now potentially same) currentCardIndex with the corrected queue
                     return;
                 }
                currentCardData = cards[actualIndex];

                // Validate loaded card data structure
                if (!currentCardData || typeof currentCardData.original !== 'string' || typeof currentCardData.translated !== 'string') {
                    console.error('Invalid card data loaded:', currentCardData, 'for original index', actualIndex);
                    statusMessage.textContent = `Error: Invalid card content for card at index ${actualIndex}. Skipping.`;
                    currentCardIndex++; // Skip this potentially corrupt card index
                    saveProgress();
                    displayCard(); // Try the next position
                    return;
                }

                // --- Update UI with Card Content ---
                foreignWordEl.textContent = currentCardData.original;
                translationEl.textContent = currentCardData.translated; // Set it even though hidden

                cardArea.classList.remove('hidden');
                controlsEl.classList.remove('hidden');
                // Update status message
                statusMessage.textContent = `Card ${currentCardIndex + 1} of ${shuffledIndices.length} in current queue.`;
                answerInput.focus();

                 // Update pronunciation button state based on the new card's data and available voices
                 checkVoiceAvailability(selectedLang);
            }

            function checkAnswer() {
                if (!currentCardData) return;

                const userAnswer = answerInput.value.trim().toLowerCase();
                const correctAnswer = currentCardData.translated.trim().toLowerCase();

                answerInput.disabled = true;
                checkAnswerBtn.style.display = 'none'; // Hide check button
                showAnswerBtn.style.display = 'none'; // Hide show button
                checkAnswerBtn.parentElement.style.display = 'none'; // Hide their container

                if (userAnswer === correctAnswer) {
                    feedbackEl.textContent = "Correct!";
                    feedbackEl.className = 'feedback correct';
                } else {
                    feedbackEl.textContent = `Incorrect. Correct: ${currentCardData.translated}`;
                    feedbackEl.className = 'feedback incorrect';
                }

                translationEl.style.display = 'block'; // Show translation
                assessmentButtons.classList.remove('hidden');
                assessmentButtons.style.display = 'flex'; // Show assessment buttons
                 // Enable pronunciation now that translation is visible
                 checkVoiceAvailability(selectedLang);
            }

            function showAnswer() {
                if (!currentCardData) return;
                answerInput.disabled = true;
                checkAnswerBtn.style.display = 'none';
                showAnswerBtn.style.display = 'none';
                checkAnswerBtn.parentElement.style.display = 'none';

                feedbackEl.textContent = `Correct: ${currentCardData.translated}`;
                feedbackEl.className = 'feedback'; // Neutral feedback class
                translationEl.style.display = 'block';
                assessmentButtons.classList.remove('hidden');
                assessmentButtons.style.display = 'flex';
                 // Enable pronunciation now that translation is visible
                 checkVoiceAvailability(selectedLang);
            }

            /**
             * Inserts the current card's original index back into the shuffledIndices array
             * at a position determined by the offset. This modifies the queue for repetition.
             * @param {number} offset - How many cards *after the current one* to insert this card.
             *                         An offset of 1 means it will be the card after the next one shown.
             */
            function repeatCardLater(offset) {
                if (currentCardIndex >= shuffledIndices.length || currentCardData === null) {
                    console.warn("Attempted to repeat card when already at end of queue or no card data.");
                    moveToNextCard(); // Should proceed to end the session or handle error state
                    return;
                }

                // Get the *original index* of the card we just assessed
                const cardToRepeatOriginalIndex = shuffledIndices[currentCardIndex];

                // Calculate where to insert the index back into the queue.
                // Add 1 to offset because splice inserts *before* the target index.
                // We want to insert `offset` cards *after* the current one finishes.
                let insertionIndex = currentCardIndex + offset + 1;

                // Clamp the insertion index to be within the bounds of the *current* queue length
                insertionIndex = Math.min(insertionIndex, shuffledIndices.length);

                 // Insert the original index back into the array at the calculated position
                 shuffledIndices.splice(insertionIndex, 0, cardToRepeatOriginalIndex);
                 console.log(`Repeating card (original index ${cardToRepeatOriginalIndex}) scheduled at queue position ${insertionIndex}. New queue length: ${shuffledIndices.length}`);

                // Crucially, NOW advance the current index to move past the card we just assessed.
                // The next call to displayCard() will show the card at the *new* currentCardIndex.
                currentCardIndex++;
                saveProgress(); // Save the updated queue and the *new* current index
                displayCard(); // Display the *next* card in the sequence
            }


            /** Advances to the next card in the shuffledIndices queue without re-inserting the current one. */
            function moveToNextCard() {
                if (currentCardIndex < shuffledIndices.length) {
                     currentCardIndex++;
                     // Save the incremented index *before* displaying the next card or finishing
                     saveProgress();
                } else {
                    // If already at or beyond the end, saveProgress might still be needed
                    // if the last action was, e.g., 'Easy' on the final card.
                    saveProgress();
                }
                // displayCard handles showing the next card or the completion message based on the updated currentCardIndex
                displayCard();
            }

            /**
            * Initializes a review session. Loads progress if available and valid, otherwise starts fresh.
            * @param {boolean} [forceNew=false] - If true, ignores and clears any saved progress.
            */
            function startReviewSession(forceNew = false) {
                if (cards.length === 0) {
                    statusMessage.textContent = "No cards loaded. Cannot start review.";
                    cardArea.classList.add('hidden');
                    controlsEl.classList.add('hidden'); // Keep controls hidden if no cards
                    return;
                }

                // Always ensure controls are potentially visible when starting a session
                controlsEl.classList.remove('hidden');

                if (forceNew) {
                    clearSavedProgress();
                    console.log("Forcing new session, progress cleared.");
                }

                // Attempt to load progress unless forcing new. loadProgress handles validation.
                const resumed = !forceNew && loadProgress();

                if (!resumed) {
                    // Start a fresh session if not resumed (or if forced)
                    currentCardIndex = 0;
                    shuffledIndices = Array.from(cards.keys()); // [0, 1, 2, ..., n-1]
                    shuffleArray(shuffledIndices);
                    console.log("Starting a new review session with shuffled indices:", shuffledIndices.slice(0, 10)); // Log first few
                    saveProgress(); // Save the initial state of the new session immediately
                }

                // Reset UI elements for the start of the session
                sessionCompleteMessage.classList.add('hidden');
                statusMessage.textContent = `Loaded ${cards.length} cards. ${resumed ? 'Resuming session.' : 'Starting new session.'}`;

                // Crucial: Initialize or re-initialize speech synthesis state *after* deciding session state
                initializeSpeechSynthesis(); // Ensures voices are checked/rechecked

                // Display the first card (or the card we resumed at)
                displayCard();
            }

            /** Fetches words from JSON file, then starts the review session. */
            async function loadWords() {
                statusMessage.textContent = `Loading words from ${WORDS_FILE_PATH}...`;
                loadingErrorEl.classList.add('hidden');
                cardArea.classList.add('hidden');
                controlsEl.classList.add('hidden'); // Hide controls during initial load
                // *** CHANGE: Removed the line that hides pronunciationControls ***
                // if (pronunciationControls) pronunciationControls.style.display = 'none';

                try {
                    // Fetch with no-cache to ensure updates to words.json are reflected
                    const response = await fetch(WORDS_FILE_PATH, { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}. Could not fetch '${WORDS_FILE_PATH}'. Check file path and network.`);
                    }
                    const jsonData = await response.json();

                    // Validate JSON structure
                    if (!Array.isArray(jsonData)) {
                        throw new Error("JSON data is not an array. Check words.json format.");
                    }
                    // More specific validation of card objects
                     const isValidStructure = jsonData.every(item =>
                         typeof item === 'object' && item !== null &&
                         typeof item.original === 'string' && item.original.trim() !== '' && // Ensure non-empty strings
                         typeof item.translated === 'string' && item.translated.trim() !== ''
                     );
                     if (!isValidStructure && jsonData.length > 0) { // Check structure only if array is not empty
                        throw new Error("JSON objects missing 'original' or 'translated' keys, or keys have empty values. Check words.json content.");
                     }

                    cards = jsonData; // Assign loaded data
                    console.log(`Successfully loaded ${cards.length} cards.`);
                    // Now that cards are loaded, start the session (which might resume or start new)
                    startReviewSession(); // Let startReviewSession handle resuming/starting new and showing controls

                } catch (error) {
                    console.error("Error loading or parsing words.json:", error);
                    loadingErrorEl.textContent = `Error: ${error.message}`;
                    loadingErrorEl.classList.remove('hidden');
                    statusMessage.textContent = "Failed to load cards. Cannot start.";
                    cards = []; // Ensure cards array is empty on error
                    cardArea.classList.add('hidden');
                    controlsEl.classList.add('hidden'); // Keep controls hidden on load error
                     // *** CHANGE: Removed the line that hides pronunciationControls ***
                    // if (pronunciationControls) pronunciationControls.style.display = 'none';
                     // Explicitly disable pronunciation if loading failed
                     if (pronounceBtn) pronounceBtn.disabled = true;
                     if (languageSelect) languageSelect.disabled = true;
                }
            }

            // --- Event Listeners ---

            // Use DOMContentLoaded to ensure HTML is parsed before attaching listeners
            document.addEventListener('DOMContentLoaded', () => {
                 // Initialize speech synthesis *early* to start voice loading process.
                 // Note: It now doesn't hide the controls itself.
                 initializeSpeechSynthesis();
                 // Then load the words. loadWords will call startReviewSession, which displays the UI.
                 loadWords();
            });

            // Card Interaction Listeners
            checkAnswerBtn.addEventListener('click', checkAnswer);
            showAnswerBtn.addEventListener('click', showAnswer);

            answerInput.addEventListener('keypress', (event) => {
                // Check if Enter key is pressed, input is enabled, and the check button is visible
                if (event.key === 'Enter' && !answerInput.disabled && checkAnswerBtn.style.display !== 'none') {
                     event.preventDefault(); // Prevent potential form submission if wrapped in form
                    checkAnswer();
                }
            });

            // Assessment Button Listeners (Using updated offsets)
            againBtn.addEventListener('click', () => {
                console.log("Selected: Again");
                repeatCardLater(AGAIN_OFFSET); // Repeat very soon
            });

            hardBtn.addEventListener('click', () => {
                console.log("Selected: Hard");
                repeatCardLater(HARD_OFFSET); // Repeat somewhat soon
            });

            goodBtn.addEventListener('click', () => { // Listener for the Good button
                console.log("Selected: Good");
                repeatCardLater(GOOD_OFFSET); // Repeat later
            });

            easyBtn.addEventListener('click', () => {
                console.log("Selected: Easy");
                moveToNextCard(); // Don't repeat this session, move to the next unique card
            });

            // New Session Button Listener
            newSessionBtn.addEventListener('click', () => {
                console.log("Starting new session manually...");
                // Stop any ongoing speech synthesis
                if (synth && synth.speaking) {
                    synth.cancel();
                }
                // Force start a new session, clearing old progress
                startReviewSession(true);
            });

        })(); // End of IIFE
    </script>

</body>
</html>
